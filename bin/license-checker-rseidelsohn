#!/usr/bin/env node

/*
Copyright (c) 2013, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://yuilibrary.com/license/
*/

const licenseChecker = require('../lib/index');
const args = require('../lib/args');
const usageMessage = require('../lib/usageMessage');
const exitProcessOrWarnIfNeeded = require('../lib/exitProcessOrWarnIfNeeded');
const parsedArgs = args.parse();
const mkdirp = require('mkdirp');
const path = require('path');
const chalk = require('chalk');
const fs = require('fs');
const cloneDeep = require('lodash.clonedeep');
const hasFailingArg = parsedArgs.failOn || parsedArgs.onlyAllow;

const kownOptions = Object.keys(args.knownOpts);
const unknownArgs = Object.keys(parsedArgs).filter((arg) => !kownOptions.includes(arg));

exitProcessOrWarnIfNeeded({ unknownArgs, parsedArgs, hasFailingArg });

licenseChecker.init(parsedArgs, function (err, json) {
    if (err) {
        console.error('An error has occurred:');
        console.error(err);
    }

    if (shouldColorizeOutput(parsedArgs)) {
        colorizeOutput(json);
    }

    const formattedOutput = getFormattedOutput(json, parsedArgs);

    if (parsedArgs.files || parsedArgs.out) {
        if (parsedArgs.files) {
            licenseChecker.asFiles(json, parsedArgs.files);
        }

        if (parsedArgs.out) {
            const dir = path.dirname(parsedArgs.out);

            mkdirp.sync(dir);
            fs.writeFileSync(parsedArgs.out, formattedOutput, 'utf8');
        }
    }

    if (!parsedArgs.out) {
        console.log(formattedOutput);
    }
});

function shouldColorizeOutput(args) {
    return args.color && !args.out && !args.files && !(args.csv || args.json || args.markdown || args.plainVertical);
}

function colorizeOutput(json) {
    Object.keys(json).forEach((key) => {
        const index = key.lastIndexOf('@');
        const colorizedKey =
            chalk.white.bgKeyword('darkslategrey')(key.slice(0, index + 1)) +
            chalk.dim('@') +
            chalk.white.bgKeyword('green')(key.slice(index + 1));
        json[colorizedKey] = json[key];

        delete json[key];
    });
}

function filterJson(limitAttributes, json) {
    let filteredJson = json;

    if (limitAttributes) {
        filteredJson = {};
        const attributes = limitAttributes.split(',').map((attribute) => attribute.trim());

        Object.keys(json).forEach((dependency) => {
            filteredJson[dependency] = licenseChecker.filterAttributes(attributes, json[dependency]);
        });
    }

    return filteredJson;
}

function getFormattedOutput(json, args) {
    let filteredJson = filterJson(args.limitAttributes, json);
    const jsonCopy = cloneDeep(filteredJson);
    filteredJson = null;

    if (args.files) {
        Object.keys(jsonCopy).forEach((moduleName) => {
            const outPath = path.join(args.files, `${moduleName}-LICENSE.txt`);
            const originalLicenseFile = jsonCopy[moduleName].licenseFile;

            if (originalLicenseFile && fs.existsSync(originalLicenseFile)) {
                if (args.relativeLicensePath) {
                    if (args.out) {
                        jsonCopy[moduleName].licenseFile = path.relative(args.out, outPath);
                    } else {
                        jsonCopy[moduleName].licenseFile = path.relative(process.cwd(), outPath);
                    }
                } else {
                    jsonCopy[moduleName].licenseFile = outPath;
                }
            }
        });
    }

    if (args.json) {
        return JSON.stringify(jsonCopy, null, 4) + '\n';
    }

    if (args.csv) {
        return licenseChecker.asCSV(jsonCopy, args.customFormat, args.csvComponentPrefix);
    }

    if (args.markdown) {
        return licenseChecker.asMarkDown(jsonCopy, args.customFormat) + '\n';
    }

    if (args.summary) {
        return licenseChecker.asSummary(jsonCopy);
    }

    if (args.plainVertical || args.angluarCli) {
        return licenseChecker.asPlainVertical(jsonCopy);
    }

    return licenseChecker.asTree(jsonCopy);
}
